#+BABEL: :cache yes
#+LATEX_HEADER: \usepackage{parskip}
#+LATEX_HEADER: \usepackage{inconsolata}
#+PROPERTY: header-args :tangle yes :comments org

#+TITLE: Emacs configuration file
#+AUTHOR: Austin Walker

* About
  
  This is an Emacs configuration file written in [[http://orgmode.org][Org mode]]. It began as a
  clone of [[https://github.com/larstvei/dot-emacs][larstvei's setup]], and now I'm slowly tweaking it to my
  needs. Every time this file is saved, all snippets of elisp code will get
  pulled into init.el thanks to the magic of =org-babel=.

* Initialization
** Meta
   
   Let's see how long everything takes to load.

   #+BEGIN_SRC emacs-lisp
     (defconst emacs-start-time (current-time))
   #+END_SRC

   Emacs can only load =.el=-files. We can use =C-c C-v t= to run
   =org-babel-tangle=, which extracts the code blocks from the current file
   into a source-specific file (in this case a =.el=-file).

   To avoid doing this each time a change is made we can add a function to
   the =after-save-hook= ensuring to always tangle and byte-compile the
   =org=-document after changes.

   #+BEGIN_SRC emacs-lisp
     (defun tangle-init ()
        "If the current buffer is 'init.org' the code-blocks are
      tangled, and the tangled file is compiled."
        (when (equal (buffer-file-name)
                     "/home/austin/.dotfiles/emacs.d/init.org")
          ;; Avoid running hooks when tangling.
          (let ((prog-mode-hook nil))
            (org-babel-tangle))))

      (add-hook 'after-save-hook 'tangle-init)
   #+END_SRC
   
   I'm adding code blocks to this file all the time. Org-mode provides a few
   [[http://orgmode.org/manual/Easy-Templates.html][structure templates]] for quickly adding new blocks, but I can make it even
   better. Everything in here is Emacs lisp, so let's alter the source code
   template a bit when I'm in this file.
	
   #+BEGIN_SRC emacs-lisp
     (defun aw/init-org-elisp-template ()
         (when (equal (buffer-file-name)
                      "/home/austin/.dotfiles/emacs.d/init.org")
           (setq-local org-structure-template-alist
                       '(("s" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC" "<src lang="emacs lisp">\n?\n</src>")))))

     (add-hook 'org-mode-hook 'aw/init-org-elisp-template)
   #+END_SRC

** Packages
*** Package List
   
    This is a list of everything that should be installed using package.el.

   #+BEGIN_SRC emacs-lisp
     (defvar required-packages
       '(ac-octave             ; Auto-completion for octave
         auto-compile          ; Automatically compile Emacs Lisp libraries
         cider                 ; Clojure repl
         clojure-mode          ; Mode for .clj files
         csharp-mode           ; Mode for C# files
         company               ; Auto-completion engine
         diminish              ; Clean up the status line a but
         evil                  ; Vi and Emacs, in harmony
         evil-leader           ; Bring back the leader key
         evil-nerd-commenter   ; Quickly comment out lines
         evil-surround         ; Tim Pope's vim plugin to surround objects
         evil-visualstar       ; Use * and # to search for the visual selection
         expand-region         ; Increase selected region by semantic units
         flycheck              ; On-the-fly syntax checking
         fullframe             ; Make certain modes take up the whole frame
         gist                  ; Quickly post code snippets to Github
         helm                  ; Super powerful completion tool
         helm-gtags            ; Use gtags for semantic completion
         helm-projectile       ; Projectile as a helm completion source
         helm-spotify          ; Spotify's entire library at my fingertips
         idle-require          ; load elisp libraries while Emacs is idle
         ibuffer-tramp         ; sort ibuffer based on tramp connection
         impatient-mode        ; Edit html in realtime
         jedi                  ; Python auto-completion for Emacs
         key-chord             ; Run commands with multiple key strokes (Helpful for Evil)
         magit                 ; Git integration for Emacs
         markdown-mode         ; Emacs Major mode for Markdown-formatted files.
         move-text             ; Move current line or region with M-up or M-down
         multi-term            ; Better terminals
         multiple-cursors      ; Multiple cursors for Emacs.
         org-trello            ; two-way sync between org and Trello
         paredit               ; minor mode for editing parentheses
         powerline             ; Rewrite of Powerline
         projectile            ; Easy navigation for files in a project
         skewer-mode           ; Use the browser as a Javascript repl
         slime                 ; Superior Lisp Interaction Mode for Emacs
         solarized-theme       ; Great color theme
         undo-tree             ; Treat undo history as a tree
         yasnippet             ; Snippet engine
         zenburn-theme         ; Nice looking low-contrast theme
         )
       "Packages which should be installed upon launch")
   #+END_SRC

*** Package Setup

   Managing extensions for Emacs is simplified using =package= which is
   built in to Emacs 24 and newer. To load downloaded packages we need to
   initialize =package=. =cl= is a library that contains many functions from
   Common Lisp, and comes in handy quite often, so we want to make sure it's
   loaded, along with =package=, which is obviously needed.

   #+BEGIN_SRC emacs-lisp
     (require 'cl)
     (require 'package)
     (setq package-enable-at-startup nil)
     (package-initialize)
   #+END_SRC

   Packages can be fetched from different mirrors, [[http://melpa.org][melpa]] is the largest
   archive and is well maintained.

   #+BEGIN_SRC emacs-lisp
     (setq package-archives
           '(("gnu" . "http://elpa.gnu.org/packages/")
             ("MELPA" . "http://melpa.org/packages/")))
   #+END_SRC

   We can define a predicate that tells us whether or not the newest version
   of a package is installed.

   #+BEGIN_SRC emacs-lisp
   (defun newest-package-installed-p (package)
     "Return true if the newest available PACKAGE is installed."
     (when (package-installed-p package)
       (let* ((local-pkg-desc (or (assq package package-alist)
                                  (assq package package--builtins)))
              (newest-pkg-desc (assq package package-archive-contents)))
         (and local-pkg-desc newest-pkg-desc
              (version-list-= (package-desc-vers (cdr local-pkg-desc))
                              (package-desc-vers (cdr newest-pkg-desc)))))))
   #+END_SRC

   Let's write a function to install a package if it is not installed or
   upgrades it if a new version has been released. Here our predicate comes
   in handy.

   #+BEGIN_SRC emacs-lisp
     (defun upgrade-or-install-package (package)
       "Unless the newest available version of PACKAGE is installed
     PACKAGE is installed and the current version is deleted."
       (unless (newest-package-installed-p package)
         (let ((get-desc (if (version< emacs-version "24.4") 'cdr 'cadr))
               (pkg-desc (assq package package-alist)))
           (when pkg-desc
             (if (version< emacs-version "24.4")
                 (package-delete (symbol-name package)
                                 (package-version-join
                                  (package-desc-vers (get-desc pkg-desc))))
               (package-delete pkg-desc)))
           (and (assq package package-archive-contents)
                (package-install package)))))
   #+END_SRC

   Also, we will need a function to find all dependencies from a given package.

   #+BEGIN_SRC emacs-lisp
   (defun dependencies (package)
     "Returns a list of dependencies from a given PACKAGE."
     (let* ((pkg-desc (assq package package-alist))
            (reqs (and pkg-desc (package-desc-reqs (cdr pkg-desc)))))
       (mapcar 'car reqs)))
   #+END_SRC

   The =package-refresh-contents= function downloads archive descriptions,
   this is a major bottleneck in this configuration. To avoid this we can
   try to only check for updates once every day or so. Here are three
   variables. The first specifies how often we should check for updates. The
   second specifies whether one should update during the initialization. The
   third is a path to a file where a time-stamp is stored in order to check
   when packages were updated last.

   #+BEGIN_SRC emacs-lisp
   (defvar days-between-updates 7)
   (defvar do-package-update-on-init t)
   (defvar package-last-update-file
     (expand-file-name (concat user-emacs-directory ".package-last-update")))
   #+END_SRC

   The tricky part is figuring out when packages were last updated. Here is
   a hacky way of doing it, using [[http://www.gnu.org/software/emacs/manual/html_node/emacs/Time-Stamps.html][time-stamps]]. By adding a time-stamp to the
   a file, we can determine whether or not to do an update. After that we
   must run the =time-stamp=-function to update the time-stamp.

   #+BEGIN_SRC emacs-lisp
   (require 'time-stamp)
   ;; Open the package-last-update-file
   (with-temp-file package-last-update-file
     (if (file-exists-p package-last-update-file)
         (progn
           ;; Insert it's original content's.
           (insert-file-contents package-last-update-file)
           (let ((start (re-search-forward time-stamp-start nil t))
                 (end (re-search-forward time-stamp-end nil t)))
             (when (and start end)
               ;; Assuming we have found a time-stamp, we check determine if it's
               ;; time to update.
               (setq do-package-update-on-init
                     (<= days-between-updates
                         (days-between
                          (current-time-string)
                          (buffer-substring-no-properties start end))))
               ;; Remember to update the time-stamp.
               (when do-package-update-on-init
                 (time-stamp)))))
       ;; If no such file exists it is created with a time-stamp.
       (insert "Time-stamp: <>")
       (time-stamp)))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (when (and do-package-update-on-init
                (y-or-n-p "Update all packages?"))
       (package-refresh-contents)

       (dolist (p required-packages)
         (when (not (package-installed-p p))
           (package-install p))))
   #+END_SRC
   
   Force =list-packages= to use the whole frame.

   #+BEGIN_SRC emacs-lisp
     (fullframe list-packages quit-window)
   #+END_SRC

*** Requires

    #+BEGIN_SRC emacs-lisp
      (require 'fullframe)
    #+END_SRC
** Sane defaults

   These are what /I/ consider to be saner defaults.

   #+BEGIN_SRC emacs-lisp
     (setq default-input-method "TeX"    ; Use TeX when toggling input method.
           doc-view-continuous t         ; At page edge goto next/previous.
           echo-keystrokes 0.1           ; Show keystrokes asap.
           inhibit-startup-message t     ; No splash screen please.
           initial-scratch-message nil   ; Clean scratch buffer.
           electric-pair-mode 1          ; Insert brackets, parentheses in pairs
           ring-bell-function 'ignore    ; Quiet.
           byte-compile-warnings nil     ; Don't show warnings when compiling elisp
           require-final-newline t       ; End files with \n
           ;; Save undo history between sessions, if you have an undo-dir
           undo-tree-auto-save-history
           (file-exists-p
            (concat user-emacs-directory "undo"))
           undo-tree-history-directory-alist
           ;; Put undo-history files in a directory, if it exists.
           (let ((undo-dir (concat user-emacs-directory "undo")))
             (and (file-exists-p undo-dir)
                  (list (cons "." undo-dir)))))
   #+END_SRC
   
   #+BEGIN_SRC emacs-lisp
     (require 'undo-tree)
     (diminish 'undo-tree-mode)
   #+END_SRC
   
   Some variables are buffer-local, so changing them using =setq= will only
   change them in a single buffer. Using =setq-default= we change the
   buffer-local variable's default value.
   
   #+BEGIN_SRC emacs-lisp
     (setq-default fill-column 80                    ; Maximum line width.
                   indent-tabs-mode nil              ; Use spaces instead of tabs.
                   split-width-threshold 100         ; Split verticly by default.
                   compilation-scroll-output 1       ; Follow compilation buffer
                   compilation-ask-about-save nil    ; Automatically save when compiling
                   auto-fill-function 'do-auto-fill) ; Auto-fill-mode everywhere.
     (diminish 'auto-fill-function)
   #+END_SRC
   
   Answering /yes/ and /no/ to each question from Emacs can be tedious, a
   single /y/ or /n/ will suffice.
   
   #+BEGIN_SRC emacs-lisp
   (fset 'yes-or-no-p 'y-or-n-p)
   #+END_SRC
   
   To avoid file system clutter we put all auto saved files in a single
   directory.
   
   #+BEGIN_SRC emacs-lisp
   (defvar emacs-autosave-directory
     (concat user-emacs-directory "autosaves/")
     "This variable dictates where to put auto saves. It is set to a
     directory called autosaves located wherever your .emacs.d/ is
     located.")

   ;; Sets all files to be backed up and auto saved in a single directory.
   (setq backup-directory-alist
         `((".*" . ,emacs-autosave-directory))
         auto-save-file-name-transforms
         `((".*" ,emacs-autosave-directory t)))
   #+END_SRC
   
   The scratch buffer is a useful place to test out bits of elisp or store some
   text temporarily. It would be nice if it was persistent, though. The
   following code will save the buffer every 5 minutes, and reload it on
   startup. ([[http://dorophone.blogspot.com/2011/11/how-to-make-emacs-scratch-buffer.html][Source]])
   
   #+BEGIN_SRC emacs-lisp
      (defun save-persistent-scratch ()
        "Save the contents of *scratch*"
             (with-current-buffer (get-buffer-create "*scratch*")
               (write-region (point-min) (point-max)
                             (concat user-emacs-directory "scratch"))))

      (defun load-persistent-scratch ()
        "Reload the scratch buffer"
        (let ((scratch-file (concat user-emacs-directory "scratch")))
          (if (file-exists-p scratch-file)
              (with-current-buffer (get-buffer "*scratch*")
                (delete-region (point-min) (point-max))
                (insert-file-contents scratch-file)))))

      (add-hook 'emacs-startup-hook 'load-persistent-scratch)
      (add-hook 'kill-emacs-hook 'save-persistent-scratch)

      (run-with-idle-timer 300 t 'save-persistent-scratch)
   #+END_SRC
   
   Set =utf-8= as preferred coding system.
   
   #+BEGIN_SRC emacs-lisp
     (set-language-environment "UTF-8")
   #+END_SRC
   
   By default the =narrow-to-region= command is disabled and issues a
   warning, because it might confuse new users. I find it useful sometimes,
   and don't want to be warned.
   
   #+BEGIN_SRC emacs-lisp
   (put 'narrow-to-region 'disabled nil)
   #+END_SRC
   
   Call =auto-complete= default configuration, which enables =auto-complete=
   globally.
   
   #+BEGIN_SRC emacs-lisp
     (eval-after-load 'auto-complete-config `(ac-config-default))
   #+END_SRC
   
   Automaticly revert =doc-view=-buffers when the file changes on disk.
   
   #+BEGIN_SRC emacs-lisp
   (add-hook 'doc-view-mode-hook 'auto-revert-mode)
   #+END_SRC
   
   Use Shift+arrow keys to jump around windows.
   
   #+BEGIN_SRC emacs-lisp
     (when (fboundp 'windmove-default-keybindings)
        (windmove-default-keybindings))
   #+END_SRC
   
** Keybindings
   
   I keep my global key bindings in a custom keymap. By loading this map in its
   very own minor mode, I can make sure they ovverride any major mode
   bindings. I'll keep adding keys to this and then load it at the end.
   
   #+BEGIN_SRC emacs-lisp
     (defvar custom-bindings-map (make-keymap)
       "A keymap for custom bindings.")
   #+END_SRC
   
   Some bindings that I haven't categorized yet:
   
  #+BEGIN_SRC emacs-lisp
    (define-key custom-bindings-map (kbd "C-'") 'er/expand-region)
    (define-key custom-bindings-map (kbd "C-;") 'er/contract-region)
    (define-key custom-bindings-map (kbd "C-c h g") 'helm-google-suggest)
    (define-key custom-bindings-map (kbd "C-c s") 'ispell-word)
   #+END_SRC

*** Key-chord-mode
    
    =key-chord-mode= allows me to use sequences of key presses to do things. It
    will come in handy when setting up =evil-mode=
    
    #+BEGIN_SRC emacs-lisp
       (setq key-chord-two-keys-delay 2)
       (key-chord-mode 1)
    #+END_SRC
    
*** Evil Mode

     Evil mode makes it possible to use Vi's modal editing within Emacs. It's
     truly the best of both worlds.
    
**** Evil-leader
    
     We can bring back the leader key with the =evil-leader= package. I've always
     been a fan of , for my leader.

     #+BEGIN_SRC emacs-lisp
       (global-evil-leader-mode)
       (evil-leader/set-leader ",")
       (evil-leader/set-key
         "f" 'helm-find-files
         "m" 'compile
         "t" 'multi-term-dedicated-toggle
         "ei" 'aw/edit-init-org
         "eI" 'aw/edit-init-el
         "es" 'aw/switch-to-scratch
         "x" 'helm-M-x)

       ;; Window stuff
       (evil-leader/set-key
         "0" 'delete-window
         "1" 'delete-other-windows
         "2" 'split-window-below
         "@" 'aw/split-window-below-and-switch
         "3" 'split-window-right
         "#" 'aw/split-window-right-and-switch
         "=" 'balance-windows)

       ;; Buffer and file stuff
       (evil-leader/set-key
         "bb" 'helm-mini
         "bk" 'kill-buffer
         "bl" 'ibuffer
         "bm" 'bookmark-jump
         "bo" 'ff-find-other-file
         "bs" 'save-buffer
         "bw" 'write-file)

       ;; Help stuff
       (evil-leader/set-key
         "hc" 'describe-key-briefly
         "hf" 'describe-function
         "hv" 'describe-variable
         "hm" 'man)

       ;; Git stuff
       (evil-leader/set-key
         "gb" 'magit-blame-mode
         "gs" 'magit-status)

       ;; Projectile/Helm stuff
       (evil-leader/set-key
         "pf" 'helm-projectile-find-file
         "pg" 'helm-projectile-grep
         "po" 'helm-occur
         "pp" 'projectile-switch-project
         "ps" 'helm-spotify)

       ;; Org stuff
       (evil-leader/set-key
         "oa" 'org-agenda-list
         "oc" 'org-capture)

       ;; Misc
       (evil-leader/set-key
         "vb" 'eval-buffer
         "vv" 'eval-last-sexp)
     #+END_SRC

**** Evil-surround

     This awesome Vim plugin will let you surround text objects with various
     items. Luckily, there's an Emacs version.
     
     #+BEGIN_SRC emacs-lisp
       (global-evil-surround-mode 1)
     #+END_SRC

**** Evil Functions

     #+BEGIN_SRC emacs-lisp
       (defun aw/edit-init-org ()
         (interactive)
         (find-file (concat user-emacs-directory "init.org")))

       (defun aw/edit-init-el ()
         (interactive)
         (find-file (concat user-emacs-directory "init.el")))

       (defun aw/switch-to-scratch ()
         (interactive)
         (switch-to-buffer "*scratch*"))

       (defun aw/split-window-right-and-switch ()
         (interactive)
         (split-window-right)
         (other-window 1))

       (defun aw/split-window-below-and-switch ()
         (interactive)
         (split-window-below)
         (other-window 1))

       (defun aw/open-line-above ()
         (interactive)
         (save-excursion
           (beginning-of-line)
           (open-line 1)))

       (defun aw/open-line-below ()
         (interactive)
         (save-excursion
           (end-of-line)
           (open-line 1)))
     #+END_SRC

**** Initialization

    Once everything is set up, we can start evil-mode.

    #+BEGIN_SRC emacs-lisp
      ;; Nerd commenter
      (evilnc-default-hotkeys)
      (global-evil-visualstar-mode t)

      (evil-mode 1)

      (define-key evil-normal-state-map "H" 'windmove-left)
      (define-key evil-normal-state-map "J" 'windmove-down)
      (define-key evil-normal-state-map "K" 'windmove-up)
      (define-key evil-normal-state-map "L" 'windmove-right)

      (key-chord-define evil-insert-state-map "jk" 'evil-normal-state)
      (key-chord-define evil-insert-state-map "kj" 'evil-normal-state)

      ;; Make tab work in terminal emacs
      (setq evil-want-C-i-jump nil)
    #+END_SRC
    
    I was really starting to miss some of these bindings from TPope's vim-unimpaired.

    #+BEGIN_SRC emacs-lisp
      (key-chord-define evil-normal-state-map "[e" 'move-text-up)
      (key-chord-define evil-normal-state-map "]e" 'move-text-down)
      (key-chord-define evil-normal-state-map "[ " 'aw/open-line-above)
      (key-chord-define evil-normal-state-map "] " 'aw/open-line-below)
      (key-chord-define evil-normal-state-map "[b" 'previous-buffer)
      (key-chord-define evil-normal-state-map "]b" 'next-buffer)
    #+END_SRC

** Visual

   First, get rid of a few things.

   #+BEGIN_SRC emacs-lisp
     (dolist (mode
              '(tool-bar-mode                ; No toolbars, more room for text.
                menu-bar-mode                ; No menu bar
                scroll-bar-mode              ; No scroll bars either.
                blink-cursor-mode))          ; The blinking cursor gets old.
       (funcall mode 0))
   #+END_SRC

   TODO: This doesn't work with emacsclient
   Change the color-theme to =solarized=. Use =wombat= in the terminal, since
   solarized doesn't play very nicely.

   #+BEGIN_SRC emacs-lisp
     (load-theme 'solarized-dark t)

     (setq solarized-scale-org-headlines nil)
   #+END_SRC

   Use the [[http://www.levien.com/type/myfonts/inconsolata.html][Inconsolata]] font if it's installed on the system.

   #+BEGIN_SRC emacs-lisp
     (when (member "Inconsolata" (font-family-list))
       (set-face-attribute 'default nil :font "Inconsolata-12")
       (add-to-list 'default-frame-alist
                    '(font . "Inconsolata-12")))
   #+END_SRC

   When interactively changing the theme (using =M-x load-theme=), the
   current custom theme is not disabled. This often gives weird-looking
   results; we can advice =load-theme= to always disable themes currently
   enabled themes.

   #+BEGIN_SRC emacs-lisp
     (defadvice load-theme
       (before disable-before-load (theme &optional no-confirm no-enable) activate)
       (mapc 'disable-theme custom-enabled-themes))
   #+END_SRC
   
   I like how Vim shows you empty lines using tildes. Emacs can do something
   similar with the variable =indicate-empty-lines=, but I'll make it look a bit
   more familiar. ([[http://www.reddit.com/r/emacs/comments/2kdztw/emacs_in_evil_mode_show_tildes_for_blank_lines/][Source]])

   #+BEGIN_SRC emacs-lisp
     (setq-default indicate-empty-lines t)
     (define-fringe-bitmap 'tilde [0 0 0 113 219 142 0 0] nil nil 'center)
     (setcdr (assq 'empty-line fringe-indicator-alist) 'tilde)
     (set-fringe-bitmap-face 'tilde 'font-lock-function-name-face)
   #+END_SRC

** Modes

   There are some modes that are enabled by default that I don't find
   particularly useful. We create a list of these modes, and disable all of
   these.


   Let's apply the same technique for enabling modes that are disabled by
   default.

   #+BEGIN_SRC emacs-lisp
     (dolist (mode
              '(column-number-mode         ; Show column number in mode line.
                delete-selection-mode      ; Replace selected text.
                dirtrack-mode              ; directory tracking in *shell*
                recentf-mode               ; Recently opened files.
                show-paren-mode))          ; Highlight matching parentheses.
       (funcall mode 1))

     (when (version< emacs-version "24.4")
       (eval-after-load 'auto-compile
         '((auto-compile-on-save-mode 1))))  ; compile .el files on save.

   #+END_SRC

   This makes =.md=-files open in =markdown-mode=.

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
   #+END_SRC

   We want to have autocompletion by default. Load company mode everywhere.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'after-init-hook 'global-company-mode)
    ;; (diminish 'company-mode)
     (setq company-idle-delay 0)
   #+END_SRC

** Helm

   Helm is an amazing completion tool for finding almost anything. We can
   replace many default functions with the helm equivalent.

   #+BEGIN_SRC emacs-lisp
     (eval-after-load 'helm
       '(progn
          (global-set-key (kbd "M-y") 'helm-show-kill-ring)
          (global-set-key (kbd "C-x b") 'helm-mini)
          (global-set-key (kbd "C-x C-f") 'helm-find-files)
          (global-set-key (kbd "M-x") 'helm-M-x)
          (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
          (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z

          (add-to-list 'helm-sources-using-default-as-input 'helm-source-man-pages)))

     ;;(diminish 'helm-mode)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (require 'helm-config)

     ;; The default "C-x c" is quite close to "C-x C-c", which quits Emacs.
     ;; Changed to "C-c h". Note: We must set "C-c h" globally, because we
     ;; cannot change `helm-command-prefix-key' once `helm-config' is loaded.
     (global-set-key (kbd "C-c h") 'helm-command-prefix)
     (global-unset-key (kbd "C-x c"))

     (when (executable-find "curl")
       (setq helm-google-suggest-use-curl-p t))

     (setq helm-quick-update                     t ; do not display invisible candidates
           helm-split-window-in-side-p           t ; open helm buffer inside current window, not occupy whole other window
           helm-M-x-fuzzy-match                  t ; fuzzy matching M-x
           helm-buffers-fuzzy-matching           t ; fuzzy matching buffer names when non--nil
           helm-recentf-fuzzy-match              t ; fuzzy matching recent files
           helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
           helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
           helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
           helm-ff-file-name-history-use-recentf t)

     (helm-mode 1)
   #+END_SRC

   When you press backspace in a helm buffer and there's nothing left to delete,
   helm will complain by saying ~Text is read only~. A much better default is to just
   close the buffer. ([[http://oremacs.com/2014/12/21/helm-backspace/][Source]])

   #+BEGIN_SRC emacs-lisp
     (defun helm-backspace ()
       (interactive)
       (condition-case nil
           (backward-delete-char 1)
         (error
          (helm-keyboard-quit))))

     (define-key helm-map (kbd "DEL") 'helm-backspace)
   #+END_SRC
   
   I use =winnner-mode= to occasionally return to a window layout. After using a
   helm buffer, =winner-undo= will display again, which isn't helpful. We can
   use a regex match to ignore it.

*** Helm-gtags
    
    #+BEGIN_SRC emacs-lisp
      (setq
       helm-gtags-ignore-case t
       helm-gtags-auto-update t
       helm-gtags-use-input-at-cursor t
       helm-gtags-pulse-at-cursor t
       helm-gtags-prefix-key "\C-cg"
       helm-gtags-suggested-key-mapping t
       )

      (require 'helm-gtags)
      ;; Enable helm-gtags-mode
      (add-hook 'dired-mode-hook 'helm-gtags-mode)
      (add-hook 'eshell-mode-hook 'helm-gtags-mode)
      (add-hook 'c-mode-hook 'helm-gtags-mode)
      (add-hook 'c++-mode-hook 'helm-gtags-mode)
      (add-hook 'asm-mode-hook 'helm-gtags-mode)

      (define-key helm-gtags-mode-map (kbd "C-c g a") 'helm-gtags-tags-in-this-function)
      (define-key helm-gtags-mode-map (kbd "C-j") 'helm-gtags-select)
      (define-key helm-gtags-mode-map (kbd "M-.") 'helm-gtags-dwim)
      (define-key helm-gtags-mode-map (kbd "M-,") 'helm-gtags-pop-stack)
      (define-key helm-gtags-mode-map (kbd "C-c <") 'helm-gtags-previous-history)
      (define-key helm-gtags-mode-map (kbd "C-c >") 'helm-gtags-next-history)
    #+END_SRC
    
** Windows
   
   =Winner-mode= allows you to jump back to previously used window
   configurations. The following massive function will ignore unwanted buffers
   when returning to a particular layout. ([[https://github.com/thierryvolpiatto/emacs-tv-config/blob/master/.emacs.el#L1706][Source]])
   
   #+BEGIN_SRC emacs-lisp
     (setq winner-boring-buffers '("*Completions*"
                                   "*Compile-Log*"
                                   "*inferior-lisp*"
                                   "*Fuzzy Completions*"
                                   "*Apropos*"
                                   "*Help*"
                                   "*cvs*"
                                   "*Buffer List*"
                                   "*Ibuffer*"
                                   ))
     (defvar winner-boring-buffers-regexp "\\*[hH]elm.*")
     (defun winner-set1 (conf)
       (let* ((buffers nil)
              (alive
               ;; Possibly update `winner-point-alist'
               (cl-loop for buf in (mapcar 'cdr (cdr conf))
                        for pos = (winner-get-point buf nil)
                        if (and pos (not (memq buf buffers)))
                        do (push buf buffers)
                        collect pos)))
         (winner-set-conf (car conf))
         (let (xwins) ; to be deleted
           ;; Restore points
           (dolist (win (winner-sorted-window-list))
             (unless (and (pop alive)
                          (setf (window-point win)
                                (winner-get-point (window-buffer win) win))
                          (not (or (member (buffer-name (window-buffer win))
                                           winner-boring-buffers)
                                   (string-match winner-boring-buffers-regexp
                                                 (buffer-name (window-buffer win))))))
               (push win xwins))) ; delete this window
           ;; Restore marks
           (letf (((current-buffer)))
             (cl-loop for buf in buffers
                      for entry = (cadr (assq buf winner-point-alist))
                      for win-ac-reg = (winner-active-region)
                      do (progn (set-buffer buf)
                                (set-mark (car entry))
                                (setf win-ac-reg (cdr entry)))))
           ;; Delete windows, whose buffers are dead or boring.
           ;; Return t if this is still a possible configuration.
           (or (null xwins)
               (progn
                 (mapc 'delete-window (cdr xwins)) ; delete all but one
                 (unless (one-window-p t)
                   (delete-window (car xwins))
                   t))))))
     (defalias 'winner-set 'winner-set1)
     (winner-mode 1)
   #+END_SRC
   
* Text Editing
** Buffer Management
   
   =Ibuffer= mode is a built-in replacement for the stock =BufferMenu=. It offers
   fancy things like filtering buffers by major mode or sorting by size. The
   [[http://www.emacswiki.org/emacs/IbufferMode][wiki]] offers a number of improvements.
   
   The size column is always listed in bytes. We can make it a bit more human
   readable by creating a custom column.

   #+BEGIN_SRC emacs-lisp
     ;; (eval-after-load 'ibuffer
     ;;   (define-ibuffer-column size-h
     ;;     (:name "Size" :inline t)
     ;;     (cond
     ;;      ((> (buffer-size) 1000000) (format "%7.1fM" (/ (buffer-size) 1000000.0)))
     ;;      ((> (buffer-size) 1000) (format "%7.1fk" (/ (buffer-size) 1000.0)))
     ;;      (t (format "%8d" (buffer-size)))))

     ;;   ;; Modify the default ibuffer-formats
     ;;   (setq ibuffer-formats
     ;;         '((mark modified read-only " "
     ;;                 (name 18 18 :left :elide) " "
     ;;                 (size-h 9 -1 :right) " "
     ;;                 (mode 16 16 :left :elide) " "
     ;;                 filename-and-process))))
   #+END_SRC
   
   #+BEGIN_SRC emacs-lisp
     (add-hook 'ibuffer-hook 'ibuffer-tramp-set-filter-groups-by-tramp-connection)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     ;; (fullframe ibuffer ibuffer-quit)
     (define-key custom-bindings-map (kbd "C-x C-b")  'ibuffer)
     (define-key custom-bindings-map (kbd "C-c r") 'rename-buffer)

     (evil-set-initial-state 'ibuffer-mode 'normal)
   #+END_SRC
   
** Snippets

   Start yasnippet

   #+BEGIN_SRC emacs-lisp
     (require 'yasnippet)
     (yas-global-mode 1)
   #+END_SRC

* Programming
** Base Environment

   Only use line numbering when programming. For opening large files, this may add some
   overhead, so we can delay rendering a bit.          

    #+BEGIN_SRC emacs-lisp
      (setq linum-delay t linum-eager nil)
      (add-hook 'prog-mode-hook 'linum-mode)
      (add-hook 'prog-mode-hook 'flycheck-mode)
    #+END_SRC

    White space stuff ([[http://www.reddit.com/r/emacs/comments/2keh6u/show_tabs_and_trailing_whitespaces_only/][Source]])

    #+BEGIN_SRC emacs-lisp
      (require 'whitespace)
      (setq whitespace-display-mappings
         ;; all numbers are Unicode codepoint in decimal. try (insert-char 182 ) to see it
        '(
          (space-mark 32 [183] [46]) ; 32 SPACE, 183 MIDDLE DOT 「·」, 46 FULL STOP 「.」
          (newline-mark 10 [182 10]) ; 10 LINE FEED
          (tab-mark 9 [187 9] [9655 9] [92 9]) ; 9 TAB, 9655 WHITE RIGHT-POINTING TRIANGLE 「▷」
          ))
      (setq whitespace-style '(face tabs trailing tab-mark))
      (set-face-attribute 'whitespace-tab nil
                          :background "#f0f0f0"
                          :foreground "#00a8a8"
                          :weight 'bold)
      (set-face-attribute 'whitespace-trailing nil
                          :background "#e4eeff"
                          :foreground "#183bc8"
                          :weight 'normal)
      (add-hook 'prog-mode-hook 'whitespace-mode)

    #+END_SRC

** Language Settings
*** C#

    Omnisharp gives us IDE capabilities for C#. Let's enable it for
    =csharp-mode=

    #+BEGIN_SRC emacs-lisp
      (add-hook 'csharp-mode-hook 'omnisharp-mode)

      ;;(omnisharp-imenu-support t)
    #+END_SRC

    Allow company to use OmniSharp for autocompletion.

    #+BEGIN_SRC emacs-lisp
       ;;(eval-after-load 'company
         ;;'(add-to-list 'company-backends 'company-omnisharp))
    #+END_SRC
*** C++

    By default, .h files are opened in C mode. I'll mostly be using them for C++
    projects, though.

    #+BEGIN_SRC emacs-lisp
    (add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
    #+END_SRC
*** FSP

    FSP (Finite state processes) is a notation that formally describes concurrent
    systems as described in the book Concurrency by Magee and Kramer. Someday
    I want to make a fully featured mode for FSP. Someone by the name of
    Esben Andreasen made a mode with basic syntax highlighting, so that will
    have to do for now.

    We'll add it manually until I have time to play around with it.

    #+BEGIN_SRC emacs-lisp
      ;; Load fsp-mode.el from its own directory
      ;; (add-to-list 'load-path "~/Dropbox/fsp-mode/")
      ;; (require 'fsp-mode)
    #+END_SRC
*** Java and C

    The =c-mode-common-hook= is a general hook that work on all C-like
    languages (C, C++, Java, etc...). I like being able to quickly compile
    using =C-c C-c= (instead of =M-x compile=), a habit from =latex-mode=.

    #+BEGIN_SRC emacs-lisp
      (defun c-setup ()
        (local-set-key (kbd "C-c C-c") 'compile)
        (setq c-default-style "linux"
              c-basic-offset 4))

      (add-hook 'c-mode-common-hook 'c-setup)
    #+END_SRC

    Some statements in Java appear often, and become tedious to write
    out. We can use abbrevs to speed this up.

    #+BEGIN_SRC emacs-lisp
    (define-abbrev-table 'java-mode-abbrev-table
      '(("psv" "public static void main(String[] args) {" nil 0)
        ("sopl" "System.out.println" nil 0)
        ("sop" "System.out.printf" nil 0)))
    #+END_SRC

    To be able to use the abbrev table defined above, =abbrev-mode= must be
    activated.

    #+BEGIN_SRC emacs-lisp
    (defun java-setup ()
      (abbrev-mode t)
      (setq-local compile-command (concat "javac " (buffer-name))))

    (add-hook 'java-mode-hook 'java-setup)
    #+END_SRC
*** LaTeX

    =.tex=-files should be associated with =latex-mode= instead of
    =tex-mode=.

    #+BEGIN_SRC emacs-lisp
    (add-to-list 'auto-mode-alist '("\\.tex\\'" . latex-mode))
    #+END_SRC

    I like using the [[https://code.google.com/p/minted/][Minted]] package for source blocks in LaTeX. To make org
    use this we add the following snippet.

    #+BEGIN_SRC emacs-lisp
      (eval-after-load 'org
        '(add-to-list 'org-latex-packages-alist '("" "minted")))
      (setq org-latex-listings 'minted)
    #+END_SRC

    Because [[https://code.google.com/p/minted/][Minted]] uses [[http://pygments.org][Pygments]] (an external process), we must add the
    =-shell-escape= option to the =org-latex-pdf-process= commands. The
    =tex-compile-commands= variable controls the default compile command for
    Tex- and LaTeX-mode, we can add the flag with a rather dirty statement
    (if anyone finds a nicer way to do this, please let me know).

    #+BEGIN_SRC emacs-lisp
      (eval-after-load 'ox-latex
        '(setq org-latex-pdf-process
               (mapcar
                (lambda (str)
                  (concat "pdflatex -shell-escape "
                          (substring str (string-match "-" str))))
                org-latex-pdf-process)))

      (eval-after-load 'tex-mode
        '(setcar (cdr (cddaar tex-compile-commands)) " -shell-escape "))
    #+END_SRC
    
    TODO flycheck
    #+BEGIN_SRC emacs-lisp
      (evil-leader/set-key-for-mode 'latex-mode
        "at" 'tex-compile)

    #+END_SRC

*** Lisps

     This advice makes =eval-last-sexp= (bound to =C-x C-e=) replace the sexp with
     the value.

     #+BEGIN_SRC emacs-lisp
       (defadvice eval-last-sexp (around replace-sexp (arg) activate)
         "Replace sexp when called with a prefix argument."
         (if arg
             (let ((pos (point)))
               ad-do-it
               (goto-char pos)
               (backward-kill-sexp)
               (forward-sexp))
           ad-do-it))
     #+END_SRC

**** Emacs Lisp

     #+BEGIN_SRC emacs-lisp
       (add-hook 'emacs-lisp-mode-hook
                 (lambda ()
                   ;; Use spaces, not tabs.
                   (setq indent-tabs-mode nil)
                   (define-key emacs-lisp-mode-map
                     "\r" 'reindent-then-newline-and-indent)))
       (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
       (add-hook 'emacs-lisp-mode-hook 'paredit-mode)
       (add-hook 'emacs-lisp-mode-hook 'flyspell-prog-mode) ;; Requires Ispell
     #+END_SRC

     Flycheck gets to be a bit much when warning about checkdoc issues, so we
     should disable those.

     #+BEGIN_SRC emacs-lisp
       (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
     #+END_SRC
*** Octave

    Make it so =.m= files are loaded in =octave-mode=.

    #+BEGIN_SRC emacs-lisp
      (autoload 'octave-mode "octave-mod" nil t)
      (setq auto-mode-alist
            (cons '("\\.m$" . octave-mode) auto-mode-alist))
    #+END_SRC

*** Python

     [[http://tkf.github.io/emacs-jedi/released/][Jedi]] offers very nice auto completion for =python-mode=. Mind that it is
     dependent on some python programs as well, so make sure you follow the
     instructions from the site.

     #+BEGIN_SRC emacs-lisp
     (require 'jedi)
     (add-hook 'python-mode-hook 'jedi:setup)
     (setq jedi:server-command
          (cons "python3" (cdr jedi:server-command))
          python-shell-interpreter "python3")
     (setq jedi:complete-on-dot t)
     ;;(add-hook 'python-mode-hook 'jedi:ac-setup)
     #+END_SRC

*** TODO Web Editing

     TODO: start httpd in correct directory

    =impatient-mode= is an amazing tool for live-editing web pages. When paired with
    =simple-httdp=, you can point your browser to =http://localhost:8080/imp= to
    see a live copy of any buffer that has impatient-mode enabled. If that buffer happens to contain HTML, CSS, or Javascript, it will be evaluated on the fly. No need to save or refresh
    anything. It's almost like they knew that I'm very... impatient.

    Let's start impatient mode for all HTML, CSS, and Javascript buffers, and
    run =httpd-start= when needed.

    #+BEGIN_SRC emacs-lisp
      (require 'simple-httpd)

      (defun aw/imp-setup ()
        (setq httpd-root "/home/austin/impatient-test/") ;; I'd like to set this based on the current buffer's working directory
        (httpd-start)
        (impatient-mode))

      ;; (add-hook 'html-mode-hook 'aw/imp-setup)
      ;; (add-hook 'css-mode-hook 'aw/imp-setup)
      ;; (add-hook 'js-mode-hook 'aw/imp-setup)
    #+END_SRC

**** HTML
**** CSS
**** JavaScript
     #+BEGIN_SRC emacs-lisp
       (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
       (add-hook 'js2-mode-hook 'ac-js2-mode)
       (setq js2-highlight-level 1)
     #+END_SRC
** CEDET
*** Semantic

    #+BEGIN_SRC emacs-lisp
      (require 'cc-mode)
      (require 'semantic)

      (global-semanticdb-minor-mode 1)
      (global-semantic-idle-scheduler-mode 1)

      (semantic-mode 1)
    #+END_SRC
** Source Control

   Magit is awesome. Open it up with the entire frame.

   #+BEGIN_SRC emacs-lisp
     (fullframe magit-status magit-mode-quit-window)
     (define-key custom-bindings-map (kbd "C-c m") 'magit-status)
   #+END_SRC

*** Diffs

    =ediff= is a powerful tool for dealing with changes to a file. You can diff
    two files or diff the current buffer against the version that's on disk. I
    haven't had to use it too much yet, but here are some tweaks that I've
    picked up.

    By default, ediff compares two buffers in a vertical split. Horizontal would
    make it a lot easier to compare things.

    #+BEGIN_SRC emacs-lisp
      (custom-set-variables
       '(ediff-window-setup-function 'ediff-setup-windows-plain)
       '(ediff-diff-options "-w")
       '(ediff-split-window-function 'split-window-horizontally))
    #+END_SRC
    
    Don't screw up my window configuration after I leave ediff.

    #+BEGIN_SRC emacs-lisp
      (add-hook 'ediff-after-quit-hook-internal 'winner-undo)
    #+END_SRC
    
    It's hard to diff org files when everything is collapsed. These functions
    will expand each hunk as I jump to it, and collapse the rest. ([[http://permalink.gmane.org/gmane.emacs.orgmode/75211][Source]])

    #+BEGIN_SRC emacs-lisp
      ;; Check for org mode and existence of buffer
      (defun aw/ediff-org-showhide(buf command &rest cmdargs)
        "If buffer exists and is orgmode then execute command"
        (if buf
            (if (eq (buffer-local-value 'major-mode (get-buffer buf)) 'org-mode)
                (save-excursion (set-buffer buf) (apply command cmdargs)))))

      (defun aw/ediff-org-unfold-tree-element ()
        "Unfold tree at diff location"
        (aw/ediff-org-showhide ediff-buffer-A 'org-reveal)
        (aw/ediff-org-showhide ediff-buffer-B 'org-reveal)
        (aw/ediff-org-showhide ediff-buffer-C 'org-reveal))
      ;;
      (defun aw/ediff-org-fold-tree ()
        "Fold tree back to top level"
        (aw/ediff-org-showhide ediff-buffer-A 'hide-sublevels 1)
        (aw/ediff-org-showhide ediff-buffer-B 'hide-sublevels 1)
        (aw/ediff-org-showhide ediff-buffer-C 'hide-sublevels 1))

      (add-hook 'ediff-select-hook 'aw/ediff-org-unfold-tree-element)
      (add-hook 'ediff-unselect-hook 'aw/ediff-org-fold-tree)
    #+END_SRC
    
    We can use a function to toggle how whitespace is treated in the
    diff. ([[http://www.reddit.com/r/emacs/comments/2513zo/ediff_tip_make_vertical_split_the_default/][Source]])

    #+BEGIN_SRC emacs-lisp
      (defun ediff-toggle-whitespace-sensitivity ()
        "Toggle whitespace sensitivity for the current EDiff run.

      This does not affect the global EDiff settings.  The function
      automatically updates the diff to reflect the change."
        (interactive)
        (let ((post-update-message
               (if (string-match " ?-w$" ediff-actual-diff-options)
                   (progn
                     (setq ediff-actual-diff-options
                           (concat ediff-diff-options " " ediff-ignore-case-option)
                           ediff-actual-diff3-options
                           (concat ediff-diff3-options " " ediff-ignore-case-option3))
                     "Whitespace sensitivity on")
                 (setq ediff-actual-diff-options
                       (concat ediff-diff-options " " ediff-ignore-case-option " -w")
                       ediff-actual-diff3-options
                       (concat ediff-diff3-options " " ediff-ignore-case-option3 " -w"))
                 "Whitespace sensitivity off")))
          (ediff-update-diffs)
          (message post-update-message)))

      (add-hook 'ediff-keymap-setup-hook
                #'(lambda () (define-key ediff-mode-map [?W] 'ediff-toggle-whitespace-sensitivity)))

    #+END_SRC
    
** Projectile

   Projectile makes it easy to navigate files in a single project. A project
   is defined as any directory containing a .git/ or other VCS
   repository. We can manually define a project by adding an empty
   =.projectile= file to our directory.

   #+BEGIN_SRC emacs-lisp
     (projectile-global-mode) ; Load Projectile everywhere
     (setq projectile-completion-system 'helm)
     (setq projectile-enable-caching t)
     ;;(diminish 'projectile-mode " P" )
     (helm-projectile-on)

   #+END_SRC
* System Stuff
** Terminals
   
   Multi-term makes working with many terminals a bit nicer. I can easily create
   and cycle through any number of terminals. There's also a "dedicated terminal"
   that I can pop up when needed.
   
   From the emacs wiki:

   #+BEGIN_SRC emacs-lisp
     (defun last-term-buffer (l)
       "Return most recently used term buffer."
       (when l
         (if (eq 'term-mode (with-current-buffer (car l) major-mode))
             (car l) (last-term-buffer (cdr l)))))

     (defun get-term ()
       "Switch to the term buffer last used, or create a new one if
         none exists, or if the current buffer is already a term."
       (interactive)
       (let ((b (last-term-buffer (buffer-list))))
         (if (or (not b) (eq 'term-mode major-mode))
             (multi-term)
           (switch-to-buffer b))))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (setq multi-term-dedicated-select-after-open-p t)
   #+END_SRC

   Some modes don't need to be in the terminal.
   #+BEGIN_SRC emacs-lisp
     (add-hook 'term-mode-hook (lambda()
                                 (yas-minor-mode -1)))
   #+END_SRC
  
  #+BEGIN_SRC emacs-lisp
     (define-key custom-bindings-map (kbd "C-c t") 'multi-term-dedicated-toggle)
     (define-key custom-bindings-map (kbd "C-c T") 'get-term)
  #+END_SRC
  
   I'd like the =C-l= to work more like the standard terminal (which works
   like running =clear=), and resolve this by simply removing the
   buffer-content. Mind that this is not how =clear= works, it simply adds a
   bunch of newlines, and puts the prompt at the top of the window, so it
   does not remove anything. In Emacs removing stuff is less of a worry,
   since we can always undo!

   #+BEGIN_SRC emacs-lisp
     (defun clear-shell ()
       "Runs `comint-truncate-buffer' with the
     `comint-buffer-maximum-size' set to zero."
       (interactive)
       (let ((comint-buffer-maximum-size 0))
        (comint-truncate-buffer)))

     (add-hook 'shell-mode-hook (lambda () (local-set-key (kbd "C-l") 'clear-shell)))
   #+END_SRC
** Config files
   
   Let's add some color to these files.

   #+BEGIN_SRC emacs-lisp
      (add-to-list 'auto-mode-alist '("\\.service\\'" . conf-unix-mode))
      (add-to-list 'auto-mode-alist '("\\.timer\\'" . conf-unix-mode))
      (add-to-list 'auto-mode-alist '("\\.target\\'" . conf-unix-mode))
      (add-to-list 'auto-mode-alist '("\\.mount\\'" . conf-unix-mode))
      (add-to-list 'auto-mode-alist '("\\.automount\\'" . conf-unix-mode))
      (add-to-list 'auto-mode-alist '("\\.slice\\'" . conf-unix-mode))
      (add-to-list 'auto-mode-alist '("\\.socket\\'" . conf-unix-mode))
      (add-to-list 'auto-mode-alist '("\\.path\\'" . conf-unix-mode))
   #+END_SRC

** Proced
   
   #+BEGIN_SRC emacs-lisp
     (defun proced-settings ()
       (proced-toggle-auto-update t))

     (add-hook 'proced-mode-hook 'proced-settings)
     (define-key custom-bindings-map (kbd "C-x p") 'proced)
   #+END_SRC
* Org-mode
  
  =Org-mode= makes up a massive part of my emacs usage. 
  
  #+BEGIN_SRC emacs-lisp
      (add-to-list 'auto-mode-alist '("\.txt\\'" . org-mode))
  #+END_SRC
  
  Expand a fold when trying to edit it.
  
  #+BEGIN_SRC emacs-lisp
      (setq org-catch-invisible-edits 'show)
  #+END_SRC
  
** Agenda
   
   I keep my schedule with =org=agenda=.
   
   #+BEGIN_SRC emacs-lisp
     (setq org-agenda-start-on-weekday nil              ; Show agenda from today.
           org-agenda-files '("~/Dropbox/org")          ; A list of agenda files.
           org-agenda-default-appointment-duration 60   ; 1 hour appointments
           org-agenda-span 1)                           ; Show only today by default

     (define-key custom-bindings-map (kbd "C-c a") 'org-agenda-list)
   #+END_SRC
   
   Show the agenda buffer in a full frame.

   #+BEGIN_SRC emacs-lisp
     ;; (fullframe org-agenda-mode org-agenda-quit)
   #+END_SRC

   When editing org-files with source-blocks, we want the source blocks to
   be themed as they would in their native mode.
   
   #+BEGIN_SRC emacs-lisp
     (setq org-src-fontify-natively t
           org-confirm-babel-evaluate nil)
   #+END_SRC
   
   This is quite an ugly fix for allowing code markup for expressions like
   ="this string"=, because the quotation marks causes problems.
   
   #+BEGIN_SRC emacs-lisp
     (setcar (nthcdr 2 org-emphasis-regexp-components) " \t\n,")
     (custom-set-variables `(org-emphasis-alist ',org-emphasis-alist))
   #+END_SRC
   
   TODO: Make =o= start a new header.
   
   #+BEGIN_SRC emacs-lisp
   #+END_SRC
   
** Babel

   Org-babel is awesome for literate programming, and it even works with
   compiled languages. To create C source blocks we just need to enable 

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'org-babel-load-languages
                  '(C . t))
   #+END_SRC
   
   #+BEGIN_SRC emacs-lisp
     (advice-add 'org-babel-C-ensure-main-wrap :override #'aw/org-c-src-main)

     (defun aw/org-c-src-main (body)
       "Wrap BODY in a \"main\" function call if none exists."
       (if (string-match "^[ \t]*[intvod]+[ \t\n\r]*main[ \t]*(.*)" body)
           body
         (format "int main(int argc, char* argv[]) {\n%s\nreturn 0;\n}\n" body)))
   #+END_SRC
** Capturing

   #+BEGIN_SRC emacs-lisp
     (setq org-default-notes-file (concat org-directory "/inbox.org"))
     (define-key custom-bindings-map (kbd "C-c o") 'org-capture)
   #+END_SRC

   The capture buffer should start in insert state. Note that the usual function
   =evil-set-initial-state= doesn't work for this case. I'm pretty sure it's
   because =org-capture-mode= is only a minor mode, but I could be wrong.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'org-capture-mode-hook 'evil-insert-state)
   #+END_SRC

*** Capture templates

    The list of templates should be empty to begin with.

    #+BEGIN_SRC emacs-lisp
      (setq org-capture-templates '())
    #+END_SRC

    Basic tasks can go straight to my inbox for reorganizing later.

    #+BEGIN_SRC emacs-lisp
      (add-to-list 'org-capture-templates
                   '("t" "Todo" entry (file+headline "~/Dropbox/org/inbox.org" "Tasks")
                    "* TODO %?\n  %i\n"))
    #+END_SRC
    

    #+BEGIN_SRC emacs-lisp
      (add-to-list 'org-capture-templates
                   '("s" "Scheduled Action"
                     entry (file+datetree "~/Dropbox/org/inbox.org")
                     "* %?\n%t\n" ))
    #+END_SRC
    
    One of the most common captures will be school assignments.

    #+BEGIN_SRC emacs-lisp
      (add-to-list 'org-capture-templates
                   '("1" "Assignment (CIS 381)"
                     entry (file+headline "~/Dropbox/org/school.org" "CIS 381")
                     "**** TODO %?\n" ))
      (add-to-list 'org-capture-templates
                   '("2" "Assignment (CIS 467)"
                     entry (file+headline "~/Dropbox/org/school.org" "CIS 467")
                     "**** TODO %?\n" ))
      (add-to-list 'org-capture-templates
                   '("3" "Assignment (CIS 481)"
                     entry (file+headline "~/Dropbox/org/school.org" "CIS 481")
                     "**** TODO %?\n" ))
      (add-to-list 'org-capture-templates
                   '("4" "Assignment (CIS 499)"
                     entry (file+headline "~/Dropbox/org/school.org" "CIS 499")
                     "**** TODO %?\n" ))
    #+END_SRC

** MobileOrg
   MobileOrg will let me sync my agenda to my phone, which will then sync
   with my calendar.

   #+BEGIN_SRC emacs-lisp
    ;; Set to the location of your Org files on your local system
    (setq org-directory "~/Dropbox/org")
    ;; Set to the name of the file where new notes will be stored
    (setq org-mobile-inbox-for-pull "~/Dropbox/org/flagged.org")
    ;; Set to <your Dropbox root directory>/MobileOrg.
    (setq org-mobile-directory "~/Dropbox/Apps/MobileOrg")
   #+END_SRC

   We can use =idle-timer= to push and pull to MobileOrg when there's no
   other activity.

   #+BEGIN_SRC emacs-lisp
     (defvar my-org-mobile-sync-timer nil)

     (defvar my-org-mobile-sync-secs (* 60 20))

     (defun my-org-mobile-sync-pull-and-push ()
       (org-mobile-pull)
       (org-mobile-push)
       (when (fboundp 'sauron-add-event)
         (sauron-add-event 'my 3 "Called org-mobile-pull and org-mobile-push")))

     (defun my-org-mobile-sync-start ()
       "Start automated `org-mobile-push'"
       (interactive)
       (setq my-org-mobile-sync-timer
             (run-with-idle-timer my-org-mobile-sync-secs t
                                  'my-org-mobile-sync-pull-and-push)))

     (defun my-org-mobile-sync-stop ()
       "Stop automated `org-mobile-push'"
       (interactive)
       (cancel-timer my-org-mobile-sync-timer))

     (my-org-mobile-sync-start)
   #+END_SRC

** Keybindings

   Org-mode uses Shift + arrow keys to change things like timestamps, TODO
   keywords, priorities, and so on. This is nice, but it gets in the way of
   windmove. The following hooks will allow shift+<arrow> to use windmove if
   there are no special org-mode contexts under the point.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'org-shiftup-final-hook 'windmove-up)
     (add-hook 'org-shiftleft-final-hook 'windmove-left)
     (add-hook 'org-shiftdown-final-hook 'windmove-down)
     (add-hook 'org-shiftright-final-hook 'windmove-right)
   #+END_SRC

   Some default org keybindings could be a bit more evil.

   #+BEGIN_SRC emacs-lisp
     (evil-define-key 'normal org-mode-map
       (kbd "M-h") 'org-metaleft
       (kbd "M-j") 'org-metadown
       (kbd "M-k") 'org-metaup
       (kbd "M-l") 'org-metaright)
   #+END_SRC

* Wrap-up
  
  We're ready to load the minor mode containing my global keybindings.

  #+BEGIN_SRC emacs-lisp
     (define-minor-mode custom-bindings-mode
       "A mode that activates custom-bindings."
       t nil custom-bindings-map)
  #+END_SRC

  The moment of truth. How did we do on load time?

  #+BEGIN_SRC emacs-lisp
    (defun aw/get-init-time ()
        (when window-system
          (let ((elapsed
                 (float-time (time-subtract (current-time) emacs-start-time))))
            (message "Loading init.el...done (%.3fs)" elapsed))))

    (add-hook 'after-init-hook 'aw/get-init-time)
  #+END_SRC

* Future plans

  I'm never done tweaking my setup. Here's some stuff that will happen in my
  next procrastination session. If you have a fix for any of these, let me know!

  - ibuffer going full frame messes up my frame layout
  - evil-mode
    - terminal emacs does not expand org headings with tab
  - org stuff
    - org-agenda should use evil keys, also probably magit and ibuffer
    - I need to sort out my org-capture workflow
      - Capture buffer should start in insert state
  - start working on a better latex workflow
  - Make impatient mode start up for me
  - Something's out of order with loading the font
    - Inconsolata doesn't load until I eval init.el again
    - Org headers are oversized until I eval again (this is a solarized thing)
  - This whole file needs to be better organized
    - use-package for packages

* License

  My Emacs configurations written in Org mode.

  Copyright (c) 2014 Austin Walker

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
