#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes :comments org

#+TITLE: Emacs configuration file
#+AUTHOR: Austin Walker

* About

  This is an Emacs configuration file written in [[http://orgmode.org][Org mode]]. It began as a
  clone of [[https://github.com/larstvei/dot-emacs][larstvei's setup]], and now I'm slowly tweaking it to my
  needs. Every time this file is saved, all snippets of elisp code will get
  pulled into init.el thanks to the magic of =org-babel=.

* Initialization
** Sane defaults

   Call =auto-complete= default configuration, which enables =auto-complete=
   globally.

   #+BEGIN_SRC emacs-lisp
     (eval-after-load 'auto-complete-config `(ac-config-default))
   #+END_SRC

** Windows

   =Winner-mode= allows you to jump back to previously used window
   configurations. The following massive function will ignore unwanted buffers
   when returning to a particular layout. ([[https://github.com/thierryvolpiatto/emacs-tv-config/blob/master/.emacs.el#L1706][Source]])

   #+BEGIN_SRC emacs-lisp
     (setq winner-boring-buffers '("*Completions*"
                                   "*Compile-Log*"
                                   "*inferior-lisp*"
                                   "*Fuzzy Completions*"
                                   "*Apropos*"
                                   "*Help*"
                                   "*cvs*"
                                   "*Buffer List*"
                                   "*Ibuffer*"
                                   ))
     (defvar winner-boring-buffers-regexp "\\*[hH]elm.*")
     (defun winner-set1 (conf)
       (let* ((buffers nil)
              (alive
               ;; Possibly update `winner-point-alist'
               (cl-loop for buf in (mapcar 'cdr (cdr conf))
                        for pos = (winner-get-point buf nil)
                        if (and pos (not (memq buf buffers)))
                        do (push buf buffers)
                        collect pos)))
         (winner-set-conf (car conf))
         (let (xwins) ; to be deleted
           ;; Restore points
           (dolist (win (winner-sorted-window-list))
             (unless (and (pop alive)
                          (setf (window-point win)
                                (winner-get-point (window-buffer win) win))
                          (not (or (member (buffer-name (window-buffer win))
                                           winner-boring-buffers)
                                   (string-match winner-boring-buffers-regexp
                                                 (buffer-name (window-buffer win))))))
               (push win xwins))) ; delete this window
           ;; Restore marks
           (letf (((current-buffer)))
             (cl-loop for buf in buffers
                      for entry = (cadr (assq buf winner-point-alist))
                      for win-ac-reg = (winner-active-region)
                      do (progn (set-buffer buf)
                                (set-mark (car entry))
                                (setf win-ac-reg (cdr entry)))))
           ;; Delete windows, whose buffers are dead or boring.
           ;; Return t if this is still a possible configuration.
           (or (null xwins)
               (progn
                 (mapc 'delete-window (cdr xwins)) ; delete all but one
                 (unless (one-window-p t)
                   (delete-window (car xwins))
                   t))))))
     (defalias 'winner-set 'winner-set1)
     (winner-mode 1)
   #+END_SRC

* Refile
  Stuff that I'm still playing around with.

  #+BEGIN_SRC emacs-lisp
    (use-package exec-path-from-shell :ensure t
      :init
      ;;(exec-path-from-shell-initialize)
      (exec-path-from-shell-copy-env "SVN_REPO"))

    (add-hook 'text-mode-hook #'bug-reference-mode)
    (add-hook 'prog-mode-hook #'bug-reference-prog-mode)

    (use-package helm-org-rifle
      :ensure t)

    (use-package abbrev
      :diminish abbrev-mode
      :config
      (if (file-exists-p abbrev-file-name)
          (quietly-read-abbrev-file)))

    ;; (use-package auctex)
    (use-package latex-pretty-symbols :ensure t)
    (use-package dockerfile-mode :ensure t)

    (use-package ox-reveal
      :ensure t
      :init
      (setq org-reveal-root "http://cdn.jsdelivr.net/reveal.js/3.0.0/"))


    (use-package htmlize
      :ensure t)

    (use-package yaml-mode :ensure t)

    (use-package anaconda-mode
      :ensure t)

    (use-package docker-tramp
      :ensure t)
  #+END_SRC

* Helm

  Helm is an amazing completion tool for finding almost anything. We can
  replace many default functions with the helm equivalent.

  #+BEGIN_SRC emacs-lisp
    (use-package helm
      :ensure t
      :diminish helm-mode
      :bind (("C-x b" . helm-mini)
             ("C-x C-f" . helm-find-files)
             ("C-c h" . helm-command-prefix)
             ("M-x" . helm-M-x)
             ("M-y" . helm-show-kill-ring))

      :init
      (setq helm-quick-update                     t ; do not display invisible candidates
            helm-split-window-in-side-p           t ; open helm buffer inside current window, not occupy whole other window
            helm-M-x-fuzzy-match                  t ; fuzzy matching M-x
            helm-buffers-fuzzy-matching           t ; fuzzy matching buffer names when non--nil
            helm-recentf-fuzzy-match              t ; fuzzy matching recent files
            helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
            helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
            helm-ff-newfile-prompt-p            nil ; Don't prompt when I create a file
            helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
            helm-ff-file-name-history-use-recentf t)
      (when (executable-find "curl")
        (setq helm-google-suggest-use-curl-p t))

      :config
      ; When I haven't entered anything, backspace should get me out of helm
      (defun helm-backspace ()
        (interactive)
        (condition-case nil
            (backward-delete-char 1)
          (error
           (helm-keyboard-quit))))

      (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
      (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z
      (define-key helm-map (kbd "DEL") 'helm-backspace)

      (helm-mode 1))

    (use-package helm-ag
      :ensure t)

    (use-package helm-projectile
      :ensure t
      :config
      (helm-projectile-on))

    (use-package helm-spotify)
  #+END_SRC

  I'd like to easily run helm-occur on all buffers that are backed by files. ([[http://stackoverflow.com/questions/14726601/sublime-text-2s-goto-anything-or-instant-search-for-emacs][Source]])

  #+BEGIN_SRC emacs-lisp
    (defun aw/helm-do-grep-all-buffers ()
      "multi-occur in all buffers backed by files."
      (interactive)
      (helm-multi-occur-1
       (delq nil
             (mapcar (lambda (b)
                       (when (buffer-file-name b) (buffer-name b)))
                     (buffer-list)))))

  #+END_SRC

  When you press backspace in a helm buffer and there's nothing left to delete,
  helm will complain by saying ~Text is read only~. A much better default is to just
  close the buffer. ([[http://oremacs.com/2014/12/21/helm-backspace/][Source]])

  #+BEGIN_SRC emacs-lisp
  #+END_SRC

** helm-gtags
   
   #+BEGIN_SRC emacs-lisp
        (use-package helm-gtags
          :ensure t
          :diminish helm-gtags-mode
          :bind (("M-." . helm-gtags-dwim)
                 ("M-," . helm-gtags-pop-stack))
          :init
          (setq helm-gtags-ignore-case t
                helm-gtags-auto-update t
                helm-gtags-use-input-at-cursor t
                helm-gtags-pulse-at-cursor t
                helm-gtags-prefix-key "\C-cg"
                helm-gtags-suggested-key-mapping t)

          :config
          (add-hook 'dired-mode-hook 'helm-gtags-mode)
          (add-hook 'eshell-mode-hook 'helm-gtags-mode)
          (add-hook 'c-mode-hook 'helm-gtags-mode)
          (add-hook 'c++-mode-hook 'helm-gtags-mode)
          (add-hook 'asm-mode-hook 'helm-gtags-mode)

          (define-key helm-gtags-mode-map (kbd "C-c g a") 'helm-gtags-tags-in-this-function)
          (define-key helm-gtags-mode-map (kbd "C-j") 'helm-gtags-select)
          (define-key helm-gtags-mode-map (kbd "C-c <") 'helm-gtags-previous-history)
          (define-key helm-gtags-mode-map (kbd "C-c >") 'helm-gtags-next-history))
   #+END_SRC
* Text Editing
** Buffer Management

   =Ibuffer= mode is a built-in replacement for the stock =BufferMenu=. It offers
   fancy things like filtering buffers by major mode or sorting by size. The
   [[http://www.emacswiki.org/emacs/IbufferMode][wiki]] offers a number of improvements.

   The size column is always listed in bytes. We can make it a bit more human
   readable by creating a custom column.

   #+BEGIN_SRC emacs-lisp
     ;; (eval-after-load 'ibuffer
     ;;   (define-ibuffer-column size-h
     ;;     (:name "Size" :inline t)
     ;;     (cond
     ;;      ((> (buffer-size) 1000000) (format "%7.1fM" (/ (buffer-size) 1000000.0)))
     ;;      ((> (buffer-size) 1000) (format "%7.1fk" (/ (buffer-size) 1000.0)))
     ;;      (t (format "%8d" (buffer-size)))))

     ;;   ;; Modify the default ibuffer-formats
     ;;   (setq ibuffer-formats
     ;;         '((mark modified read-only " "
     ;;                 (name 18 18 :left :elide) " "
     ;;                 (size-h 9 -1 :right) " "
     ;;                 (mode 16 16 :left :elide) " "
     ;;                 filename-and-process))))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (add-hook 'ibuffer-hook 'ibuffer-tramp-set-filter-groups-by-tramp-connection)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     ;; (fullframe ibuffer ibuffer-quit)
     (define-key custom-bindings-map (kbd "C-x C-b")  'ibuffer)
     (define-key custom-bindings-map (kbd "C-c r") 'rename-buffer)

     (evil-set-initial-state 'ibuffer-mode 'normal)
   #+END_SRC

** Editing Large Files

   =VLF-mode= allows me to open up huge files in batches, which is really useful when going through
   massive log files. Here I just require it so I have the option of using it. More configuration to follow.

   #+BEGIN_SRC emacs-lisp
     (use-package vlf
       :ensure t
       :config
       (require 'vlf-setup))
   #+END_SRC
* Programming
** Language Settings
*** FSP

    FSP (Finite state processes) is a notation that formally describes concurrent
    systems as described in the book Concurrency by Magee and Kramer. Someday
    I want to make a fully featured mode for FSP. Someone by the name of
    Esben Andreasen made a mode with basic syntax highlighting, so that will
    have to do for now.

    We'll add it manually until I have time to play around with it.

    #+BEGIN_SRC emacs-lisp
      ;; Load fsp-mode.el from its own directory
      ;; (add-to-list 'load-path "~/Dropbox/fsp-mode/")
      ;; (require 'fsp-mode)
    #+END_SRC
*** LaTeX

    =.tex=-files should be associated with =latex-mode= instead of
    =tex-mode=.

    #+BEGIN_SRC emacs-lisp
      (use-package latex-mode
       :mode "\\.tex\\'" )
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (evil-leader/set-key-for-mode 'latex-mode
        "at" 'tex-compile)

    #+END_SRC

*** Lisps

    This advice makes =eval-last-sexp= (bound to =C-x C-e=) replace the sexp with
    the value.

    #+BEGIN_SRC emacs-lisp
       (defadvice eval-last-sexp (around replace-sexp (arg) activate)
         "Replace sexp when called with a prefix argument."
         (if arg
             (let ((pos (point)))
               ad-do-it
               (goto-char pos)
               (backward-kill-sexp)
               (forward-sexp))
           ad-do-it))
    #+END_SRC

**** Clojure

     #+BEGIN_SRC emacs-lisp
       (use-package clojure-mode
         :ensure t)

       (use-package cider
         :ensure t)
     #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (evil-leader/set-key-for-mode 'clojure-mode
        "vv" 'cider-eval-last-sexp
        "vV" 'cider-eval-last-sexp-to-repl)
    #+END_SRC
**** Emacs Lisp

     #+BEGIN_SRC emacs-lisp
       (add-hook 'emacs-lisp-mode-hook
                 (lambda ()
                   ;; Use spaces, not tabs.
                   (setq indent-tabs-mode nil)
                   (define-key emacs-lisp-mode-map
                     "\r" 'reindent-then-newline-and-indent)))
       (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
       (add-hook 'emacs-lisp-mode-hook 'flyspell-prog-mode) ;; Requires Ispell
     #+END_SRC
**** Racket

Use racket in geiser-mode.

#+BEGIN_SRC emacs-lisp
    (use-package racket-mode
      :mode "\\.rkt")
#+END_SRC
*** Markdown

    #+BEGIN_SRC emacs-lisp
      (use-package markdown-mode
        :mode "\\.md\\'")

    #+END_SRC
*** Octave

    Make it so =.m= files are loaded in =octave-mode=.

    #+BEGIN_SRC emacs-lisp
      (use-package octave-mode
        :mode "\\.m$")
    #+END_SRC

*** Python

     [[http://tkf.github.io/emacs-jedi/released/][Jedi]] offers very nice auto completion for =python-mode=. Mind that it is
     dependent on some python programs as well, so make sure you follow the
     instructions from the site.

     #+BEGIN_SRC emacs-lisp
       (use-package jedi
         :init
         (setq jedi:complete-on-dot t))
       ;; (add-hook 'python-mode-hook 'jedi:setup)
       ;; (setq jedi:server-command
       ;;      (cons "python3" (cdr jedi:server-command))
       ;;      python-shell-interpreter "python3")

       ;;(add-hook 'python-mode-hook 'jedi:ac-setup)
     #+END_SRC

*** Web Editing

     TODO: start httpd in correct directory

    =impatient-mode= is an amazing tool for live-editing web pages. When paired with
    =simple-httdp=, you can point your browser to =http://localhost:8080/imp= to
    see a live copy of any buffer that has impatient-mode enabled. If that buffer happens to contain HTML, CSS, or Javascript, it will be evaluated on the fly. No need to save or refresh
    anything. It's almost like they knew that I'm very... impatient.

    Let's start impatient mode for all HTML, CSS, and Javascript buffers, and
    run =httpd-start= when needed.

    #+BEGIN_SRC emacs-lisp
      ;; TODO: set up impatient mode
      (use-package impatient-mode)

      (defun aw/imp-setup ()
        (setq httpd-root "/home/austin/Dropbox/school/cis467/hw3/") ;; I'd like to set this based on the current buffer's working directory
        (httpd-start)
        (impatient-mode))

      ;; (add-hook 'html-mode-hook 'aw/imp-setup)
      ;; (add-hook 'css-mode-hook 'aw/imp-setup)
      ;; (add-hook 'js-mode-hook 'aw/imp-setup)
    #+END_SRC

**** HTML
**** CSS
**** JavaScript
     #+BEGIN_SRC emacs-lisp
       (use-package js2-mode
         :ensure t
         ;; :mode "\\.js\\"

         :init
         (setq js2-highlight-level 1)

         :config
         (add-hook 'js2-mode-hook 'ac-js2-mode))
     #+END_SRC
** CEDET
*** Semantic

    #+BEGIN_SRC emacs-lisp
      (require 'cc-mode)
      (require 'semantic)

      (global-semanticdb-minor-mode 1)
      (global-semantic-idle-scheduler-mode 1)

      (semantic-mode 1)
    #+END_SRC
*** function-args

    #+BEGIN_SRC emacs-lisp
      (use-package function-args
        :ensure t
        :diminish FA
        :config
        (fa-config-default)
        (define-key c-mode-map  [(control tab)] 'moo-complete)
        (define-key c++-mode-map  [(control tab)] 'moo-complete)
        (define-key c-mode-map (kbd "M-o")  'fa-show)
        (define-key c++-mode-map (kbd "M-o")  'fa-show))
    #+END_SRC

* System Stuff
** Dired

   By default, dired shows file sizes in bytes. We can change the switches used by ls to make things human readable.

   #+BEGIN_SRC emacs-lisp
     (setq dired-listing-switches "-alh")
   #+END_SRC

** Terminals

   Multi-term makes working with many terminals a bit nicer. I can easily create
   and cycle through any number of terminals. There's also a "dedicated terminal"
   that I can pop up when needed.

   From the emacs wiki:

   #+BEGIN_SRC emacs-lisp
     (use-package multi-term :ensure t)           ; Better terminals

     (defun last-term-buffer (l)
       "Return most recently used term buffer."
       (when l
         (if (eq 'term-mode (with-current-buffer (car l) major-mode))
             (car l) (last-term-buffer (cdr l)))))

     (defun get-term ()
       "Switch to the term buffer last used, or create a new one if
         none exists, or if the current buffer is already a term."
       (interactive)
       (let ((b (last-term-buffer (buffer-list))))
         (if (or (not b) (eq 'term-mode major-mode))
             (multi-term)
           (switch-to-buffer b))))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (setq multi-term-dedicated-select-after-open-p t)
   #+END_SRC

   Some modes don't need to be in the terminal.
   #+BEGIN_SRC emacs-lisp
     ;; (add-hook 'term-mode-hook (lambda()
     ;;                             (yas-minor-mode -1)))
   #+END_SRC

  #+BEGIN_SRC emacs-lisp
     (define-key custom-bindings-map (kbd "C-c t") 'multi-term-dedicated-toggle)
     (define-key custom-bindings-map (kbd "C-c T") 'get-term)
  #+END_SRC

   I'd like the =C-l= to work more like the standard terminal (which works
   like running =clear=), and resolve this by simply removing the
   buffer-content. Mind that this is not how =clear= works, it simply adds a
   bunch of newlines, and puts the prompt at the top of the window, so it
   does not remove anything. In Emacs removing stuff is less of a worry,
   since we can always undo!

   #+BEGIN_SRC emacs-lisp
     (defun clear-shell ()
       "Runs `comint-truncate-buffer' with the
     `comint-buffer-maximum-size' set to zero."
       (interactive)
       (let ((comint-buffer-maximum-size 0))
        (comint-truncate-buffer)))

     (add-hook 'shell-mode-hook (lambda () (local-set-key (kbd "C-l") 'clear-shell)))
   #+END_SRC
** Config files

   Let's add some color to these files.

   #+BEGIN_SRC emacs-lisp
      (add-to-list 'auto-mode-alist '("\\.service\\'" . conf-unix-mode))
      (add-to-list 'auto-mode-alist '("\\.timer\\'" . conf-unix-mode))
      (add-to-list 'auto-mode-alist '("\\.target\\'" . conf-unix-mode))
      (add-to-list 'auto-mode-alist '("\\.mount\\'" . conf-unix-mode))
      (add-to-list 'auto-mode-alist '("\\.automount\\'" . conf-unix-mode))
      (add-to-list 'auto-mode-alist '("\\.slice\\'" . conf-unix-mode))
      (add-to-list 'auto-mode-alist '("\\.socket\\'" . conf-unix-mode))
      (add-to-list 'auto-mode-alist '("\\.path\\'" . conf-unix-mode))
   #+END_SRC

** Proced

   #+BEGIN_SRC emacs-lisp
     (defun proced-settings ()
       (proced-toggle-auto-update t))

     (add-hook 'proced-mode-hook 'proced-settings)
     (define-key custom-bindings-map (kbd "C-x p") 'proced)
   #+END_SRC
* Org-mode

  =Org-mode= makes up a massive part of my emacs usage.

  #+BEGIN_SRC emacs-lisp
    (defun aw/org-setup ()
      (interactive)
      (turn-on-auto-fill)
      (turn-on-flyspell))

    (use-package org-mode
      :pin manual
      :mode "\\.txt\\'"

      :init
      (setq org-agenda-files '("~/org/")
            org-agenda-default-appointment-duration 60     ; 1 hour appointments
            org-agenda-span 1                              ; Show only today by default
            org-agenda-start-on-weekday 0                  ; Show agenda from Sunday.
            org-catch-invisible-edits 'show                ; Expand a fold when trying to edit it
            org-confirm-babel-evaluate nil                 ; Don't ask to evaluate src blocks
            org-directory "~/org/"
            org-hide-emphasis-markers t                    ; Don't show markup characters
            org-link-search-must-match-exact-headline nil  ; Create internal links with only a partial match
            org-outline-path-complete-in-steps nil         ; Refile in a single go
            org-refile-use-outline-path t                  ; Show full paths for refiling
            org-return-follows-link t                      ; Hit return to open links
            org-src-fontify-natively t                     ; Highlight src blocks natively
            org-startup-folded t                           ; Start buffer folded
            org-startup-indented t)                        ; Indent sections based on their header level

                                            ; Show dots instead of dashes
      (font-lock-add-keywords 'org-mode
                              '(("^ +\\([-*]\\) "
                                 (0 (prog1 ()
                                      (compose-region (match-beginning 1) (match-end 1) "â€¢"))))))

      :config
      (add-hook 'org-mode-hook #'aw/org-setup)
      (fullframe org-agenda org-agenda-Quit))

    (use-package org-bullets
      :ensure t
      :config
      (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))

  #+END_SRC

  Of course, I use git to keep my org files under control. We should periodically make sure everything is in sync.

  #+BEGIN_SRC emacs-lisp
    (defun aw/sync-org-directory ()
      "Save all org buffers and then run my script to sync everything with my git remote.
    If there are new changes, my org buffers should auto revert"
      (interactive)
      (let ((default-directory org-directory))
        (org-save-all-org-buffers)
        (save-window-excursion
          (shell-command "./maintainOrgFiles" "*maintainOrgFiles"))))

    (run-with-idle-timer 300 t 'aw/sync-org-directory)
  #+END_SRC

** Agenda

   I'm just starting to play around with custom agenda commands.

   #+BEGIN_SRC emacs-lisp
          (setq org-agenda-custom-commands
                '(("w" "Work"
                   ((tags-todo "+WORK-backlog"
                               ((org-agenda-overriding-header "Tasks")
                                (org-agenda-remove-tags t)
                                (org-agenda-sorting-strategy
                                 '(todo-state-down priority-down))
                                (org-agenda-skip-function
                                 '(org-agenda-skip-entry-if 'todo '("IDEA" "STALLED" "STARTED" "BLOCKED")))))
                    (todo "BLOCKED"
                          ((org-agenda-overriding-header "Blocked")))
                    (todo "FIXED"
                          ((org-agenda-overriding-header "Awaiting verification")))
                    (todo "STALLED|STARTED|QA"
                          ((org-agenda-overriding-header "Stories")))))))
   #+END_SRC

   Mark tasks as complete when all subtasks are done.

#+BEGIN_SRC emacs-lisp
  (defun org-summary-todo (n-done n-not-done)
    "Switch entry to DONE when all subentries are done, to TODO otherwise."
    (let (org-log-done org-log-states)   ; turn off logging
      (org-todo (if (= n-not-done 0) "DONE" "TODO"))))

  (add-hook 'org-after-todo-statistics-hook 'org-summary-todo)

  (setq org-hierarchical-todo-statistics 'nil)
#+END_SRC
** Babel

   Org-babel is awesome for literate programming, and it even works with
   compiled languages. To create C source blocks we just need to enable

   #+BEGIN_SRC emacs-lisp
     (with-eval-after-load 'org
       (org-babel-do-load-languages
        'org-babel-load-languages
        '((emacs-lisp . t)
          (C . t)
          (dot . t)
          (gnuplot . t)
          (sh . t)
          (python . t)
          (octave . t))))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (advice-add 'org-babel-C-ensure-main-wrap :override #'aw/org-c-src-main)

     (defun aw/org-c-src-main (body)
       "Wrap BODY in a \"main\" function call if none exists."
       (if (string-match "^[ \t]*[intvod]+[ \t\n\r]*main[ \t]*(.*)" body)
           body
         (format "int main(int argc, char* argv[]) {\n%s\nreturn 0;\n}\n" body)))
   #+END_SRC

   We can ensure that src blocks in certain languages receive some default headers.

   #+BEGIN_SRC emacs-lisp
     (setq org-babel-default-header-args:sh
           '((:shebang . "#!/bin/bash")))

     (setq org-babel-default-header-args:python
           '((:shebang . "#!/bin/python")))
   #+END_SRC

** Capturing

   Notes that I capture are generally sent to =refile.org= for further review. We can use Helm to
   quickly refile them to any headline within my =org-agenda-files=.

   #+BEGIN_SRC emacs-lisp
     (setq org-refile-targets '((nil :maxlevel . 9)
                                (org-agenda-files :maxlevel . 9)))

     (defun aw/verify-refile-target ()
       "Exclude todo keywords with a done state from refile targets"
       (not (member (nth 2 (org-heading-components)) org-done-keywords)))

     (setq org-refile-target-verify-function 'aw/verify-refile-target)
   #+END_SRC

   The capture buffer should start in insert state. Note that the usual function
   =evil-set-initial-state= doesn't work for this case. I'm pretty sure it's
   because =org-capture-mode= is only a minor mode, but I could be wrong.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'org-capture-mode-hook 'evil-insert-state)
   #+END_SRC

*** Capture templates

    #+BEGIN_SRC emacs-lisp
      (setq org-capture-templates
            '(("a" "Teamforge Artifact" entry (file+headline (concat org-directory "work.org") "Refile")
               "* OPEN artf%^{artifact} - %^{description}\n [[teamforge:%\\1][Teamforge Link]]" :immediate-finish 1)
              ("j" "Journal Entry" plain (file+datetree (concat org-directory "journal.org"))
               "    %?    %u" :empty-lines 1)
              ("s" "Scheduled Action" entry (file+datetree+prompt (concat org-directory "calendar.org"))
                  "* %?\n%t\n")
              ("t" "Todo" entry (file+datetree+prompt (concat org-directory "calendar.org"))
                "* TODO %?\n  SCHEDULED: %t\n")))
    #+END_SRC

** Habits

   Org-mode has a nice feature called org-habit that I can use to track day to
   day things. Let's load the module first.

   #+BEGIN_SRC emacs-lisp
     ;; (add-to-list 'org-modules
     ;;              'org-habit)

   #+END_SRC

** MobileOrg
   MobileOrg will let me sync my agenda to my phone, which will then sync
   with my calendar.

   #+BEGIN_SRC emacs-lisp
    ;; Set to the name of the file where new notes will be stored
    (setq org-mobile-inbox-for-pull "~/Dropbox/org/flagged.org")
    ;; Set to <your Dropbox root directory>/MobileOrg.
    (setq org-mobile-directory "~/Dropbox/Apps/MobileOrg")
   #+END_SRC

   We can use =idle-timer= to push and pull to MobileOrg when there's no
   other activity.

   #+BEGIN_SRC emacs-lisp
     (defvar my-org-mobile-sync-timer nil)

     (defun my-org-mobile-sync-pull-and-push ()
       (org-mobile-pull)
       (org-mobile-push)
       (when (fboundp 'sauron-add-event)
         (sauron-add-event 'my 3 "Called org-mobile-pull and org-mobile-push")))

     (defun my-org-mobile-sync-start ()
       "Start automated `org-mobile-push'"
       (interactive)
       (setq my-org-mobile-sync-timer
             (run-with-idle-timer 300 t
                                  'my-org-mobile-sync-pull-and-push)))

     (defun my-org-mobile-sync-stop ()
       "Stop automated `org-mobile-push'"
       (interactive)
       (cancel-timer my-org-mobile-sync-timer))

     (my-org-mobile-sync-start)
   #+END_SRC

** Keybindings

   Org-mode uses Shift + arrow keys to change things like timestamps, TODO
   keywords, priorities, and so on. This is nice, but it gets in the way of
   windmove. The following hooks will allow shift+<arrow> to use windmove if
   there are no special org-mode contexts under the point.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'org-shiftup-final-hook 'windmove-up)
     (add-hook 'org-shiftleft-final-hook 'windmove-left)
     (add-hook 'org-shiftdown-final-hook 'windmove-down)
     (add-hook 'org-shiftright-final-hook 'windmove-right)
   #+END_SRC

   Some default org keybindings could be a bit more evil.

   #+BEGIN_SRC emacs-lisp
     (evil-define-key 'normal org-mode-map
       (kbd "M-h") 'org-metaleft
       (kbd "M-j") 'org-metadown
       (kbd "M-k") 'org-metaup
       (kbd "M-l") 'org-metaright)
   #+END_SRC

* Future plans

  I'm never done tweaking my setup. Here's some stuff that will happen in my
  next procrastination session. If you have a fix for any of these, let me know!

  - ibuffer going full frame messes up my frame layout
  - org stuff
    - org-agenda should use evil keys, also probably magit and ibuffer
    - I need to sort out my org-capture workflow
  - start working on a better latex workflow
  - Hard line wrapping gets annoying when programming
  - restclient mode is cool
  - log files should use auto-revert-tail-mode

